<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¡ãƒ©æ˜ åƒé€ä¿¡ - 4ç•ªå‡ºå£</title>
    <link rel="stylesheet" href="/css/style.css">
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>ğŸ“¹ ã‚«ãƒ¡ãƒ©æ˜ åƒé€ä¿¡</h1>

            <div class="connection-status" id="connection-status">æ¥ç¶šä¸­...</div>

            <div class="status-display">
                <h2>ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
                <div class="video-container">
                    <video id="local-video" autoplay playsinline muted></video>
                </div>
            </div>

            <div class="button-group">
                <button class="btn btn-success btn-large" id="start-btn">
                    ğŸ“¹ é€ä¿¡é–‹å§‹
                </button>
                <button class="btn btn-danger btn-large" id="stop-btn" style="display: none;">
                    â¹ï¸ é€ä¿¡åœæ­¢
                </button>
                <button class="btn btn-large" id="switch-camera-btn" style="display: none;">
                    ğŸ”„ ã‚«ãƒ¡ãƒ©åˆ‡æ›¿
                </button>
            </div>

            <div id="stream-status" class="status-display" style="display: none;">
                <div class="status-item">
                    <span class="status-label">é€ä¿¡çŠ¶æ…‹:</span>
                    <span class="status-value" id="stream-state">åœæ­¢ä¸­</span>
                </div>
                <div class="status-item">
                    <span class="status-label">ã‚«ãƒ¡ãƒ©:</span>
                    <span class="status-value" id="camera-type">æœªé¸æŠ</span>
                </div>
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">ğŸ  ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const localVideo = document.getElementById('local-video');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const switchCameraBtn = document.getElementById('switch-camera-btn');
        const streamStatus = document.getElementById('stream-status');
        const streamState = document.getElementById('stream-state');
        const cameraType = document.getElementById('camera-type');

        let localStream = null;
        let peerConnections = {}; // streamId -> RTCPeerConnection
        let currentFacingMode = 'user'; // 'user' = ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©, 'environment' = ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©
        let myStreamId = Math.random().toString(36).substr(2, 9); // ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ID

        // æ¥ç¶šçŠ¶æ…‹ã®è¡¨ç¤º
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = 'âœ… ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™';
                statusElement.className = 'connection-status connected';
                // ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡å´ã¨ã—ã¦ç™»éŒ²
                wsClient.send({
                    type: 'register',
                    role: 'sender',
                    streamId: myStreamId
                });
            } else {
                statusElement.textContent = 'âŒ ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é–‹å§‹
        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                cameraType.textContent = currentFacingMode === 'user' ? 'ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©' : 'ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©';
                streamState.textContent = 'é€ä¿¡ä¸­';
                streamState.style.color = '#56ab2f';
                streamStatus.style.display = 'block';

                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                switchCameraBtn.style.display = 'inline-block';

                // ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡é–‹å§‹ã‚’é€šçŸ¥ï¼ˆæ—¢å­˜ã®å—ä¿¡å´ã«æ¥ç¶šï¼‰
                console.log('é€ä¿¡é–‹å§‹ã‚’é€šçŸ¥');

            } catch (error) {
                console.error('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n' + error.message);
            }
        }

        // ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
            }

            // ã™ã¹ã¦ã®ãƒ”ã‚¢æ¥ç¶šã‚’é–‰ã˜ã‚‹
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            streamState.textContent = 'åœæ­¢ä¸­';
            streamState.style.color = '#999';
            cameraType.textContent = 'æœªé¸æŠ';

            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            switchCameraBtn.style.display = 'none';
        }

        // ã‚«ãƒ¡ãƒ©ã‚’åˆ‡ã‚Šæ›¿ãˆ
        async function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            stopCamera();
            await startCamera();
        }

        // WebRTCæ¥ç¶šã‚’é–‹å§‹ï¼ˆå—ä¿¡å´ã”ã¨ã«ä½œæˆï¼‰
        async function createPeerConnection(receiverId) {
            try {
                const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ 
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // æ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–
                peerConnection.onconnectionstatechange = () => {
                    console.log(`é€ä¿¡å´æ¥ç¶šçŠ¶æ…‹ (${receiverId}):`, peerConnection.connectionState);
                };

                // ICEå€™è£œã‚’é€ä¿¡
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log(`é€ä¿¡å´ICEå€™è£œã‚’é€ä¿¡ (${receiverId})`);
                        wsClient.send({
                            type: 'webrtc-ice-candidate',
                            candidate: event.candidate,
                            streamId: myStreamId,
                            receiverId: receiverId
                        });
                    }
                };

                // Offerã‚’ä½œæˆã—ã¦é€ä¿¡
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                console.log(`Offerã‚’é€ä¿¡ (${receiverId})`);
                wsClient.send({
                    type: 'webrtc-offer',
                    offer: offer,
                    streamId: myStreamId,
                    receiverId: receiverId
                });

                peerConnections[receiverId] = peerConnection;

            } catch (error) {
                console.error('WebRTCæ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
                alert('WebRTCæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // WebRTCã‚·ã‚°ãƒŠãƒªãƒ³ã‚°
        wsClient.onMessage(async (data) => {
            try {
                // æ–°ã—ã„å—ä¿¡å´ãŒæ¥ç¶šã—ãŸå ´åˆ
                if (data.type === 'new-receiver' && localStream) {
                    console.log('æ–°ã—ã„å—ä¿¡å´ã‚’æ¤œå‡º:', data.receiverId);
                    await createPeerConnection(data.receiverId);
                }
                // Answerã‚’å—ä¿¡
                else if (data.type === 'webrtc-answer') {
                    const receiverId = data.receiverId;
                    const pc = peerConnections[receiverId];
                    if (pc) {
                        console.log(`Answerã‚’å—ä¿¡ (${receiverId})`);
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    }
                }
                // ICEå€™è£œã‚’å—ä¿¡
                else if (data.type === 'webrtc-ice-candidate' && data.streamId === myStreamId) {
                    const receiverId = data.receiverId;
                    const pc = peerConnections[receiverId];
                    if (pc) {
                        console.log(`å—ä¿¡å´ã‹ã‚‰ICEå€™è£œã‚’å—ä¿¡ (${receiverId})`);
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                }
                // å—ä¿¡å´ãŒåˆ‡æ–­ã—ãŸå ´åˆ
                else if (data.type === 'receiver-disconnected') {
                    const receiverId = data.receiverId;
                    if (peerConnections[receiverId]) {
                        peerConnections[receiverId].close();
                        delete peerConnections[receiverId];
                        console.log(`å—ä¿¡å´ãŒåˆ‡æ–­ã—ã¾ã—ãŸ (${receiverId})`);
                    }
                }
            } catch (error) {
                console.error('ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
            }
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        startBtn.addEventListener('click', startCamera);
        stopBtn.addEventListener('click', stopCamera);
        switchCameraBtn.addEventListener('click', switchCamera);
    </script>
</body>

</html>