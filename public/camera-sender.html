<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カメラ映像送信 - 4番出口</title>
    <link rel="stylesheet" href="/css/style.css">
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>📹 カメラ映像送信</h1>

            <div class="connection-status" id="connection-status">接続中...</div>

            <!-- HTTPS警告メッセージ -->
            <div id="https-warning" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin: 15px 0; color: #856404;">
                <strong>⚠️ 警告:</strong> HTTP接続が検出されました。<br>
                iOSデバイスでカメラを使用するにはHTTPS接続が必要です。<br>
                <small>現在のURL: <code id="current-url"></code></small>
            </div>

            <!-- 送信ID設定 -->
            <div class="status-display">
                <h2>送信側設定</h2>
                <div class="status-item">
                    <label for="sender-name" style="display: block; margin-bottom: 5px; font-weight: bold;">表示名:</label>
                    <input type="text" id="sender-name" placeholder="例: カメラ1, 正面カメラ" style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #667eea; border-radius: 5px;" />
                </div>
                <div class="status-item" style="margin-top: 10px;">
                    <span class="status-label">あなたのID:</span>
                    <span class="status-value" id="my-stream-id" style="font-family: monospace; background: #f0f0f0; padding: 5px 10px; border-radius: 3px;">-</span>
                </div>
            </div>

            <div class="status-display">
                <h2>カメラプレビュー</h2>
                <div class="video-container">
                    <video id="local-video" autoplay playsinline muted></video>
                </div>
            </div>

            <div class="button-group">
                <button class="btn btn-success btn-large" id="start-btn">
                    📹 送信開始
                </button>
                <button class="btn btn-danger btn-large" id="stop-btn" style="display: none;">
                    ⏹️ 送信停止
                </button>
                <button class="btn btn-large" id="switch-camera-btn" style="display: none;">
                    🔄 カメラ切替
                </button>
            </div>

            <div id="stream-status" class="status-display" style="display: none;">
                <div class="status-item">
                    <span class="status-label">送信状態:</span>
                    <span class="status-value" id="stream-state">停止中</span>
                </div>
                <div class="status-item">
                    <span class="status-label">カメラ:</span>
                    <span class="status-value" id="camera-type">未選択</span>
                </div>
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">🏠 ホームに戻る</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const localVideo = document.getElementById('local-video');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const switchCameraBtn = document.getElementById('switch-camera-btn');
        const streamStatus = document.getElementById('stream-status');
        const streamState = document.getElementById('stream-state');
        const cameraType = document.getElementById('camera-type');
        const httpsWarning = document.getElementById('https-warning');
        const currentUrlElement = document.getElementById('current-url');
        const senderNameInput = document.getElementById('sender-name');
        const myStreamIdElement = document.getElementById('my-stream-id');

        // HTTPS状態チェック
        if (window.location.protocol !== 'https:' && 
            window.location.hostname !== 'localhost' && 
            window.location.hostname !== '127.0.0.1') {
            httpsWarning.style.display = 'block';
            currentUrlElement.textContent = window.location.href;
        }

        let localStream = null;
        let peerConnections = {}; // receiverId -> RTCPeerConnection
        let currentFacingMode = 'user'; // 'user' = インカメラ, 'environment' = アウトカメラ
        let myStreamId = Math.random().toString(36).substr(2, 9); // このストリームのID

        // ストリームIDを表示
        myStreamIdElement.textContent = myStreamId;

        // ローカルストレージから前回の表示名を復元
        const savedName = localStorage.getItem('senderName');
        if (savedName) {
            senderNameInput.value = savedName;
        }

        // 表示名が変更されたら保存
        senderNameInput.addEventListener('input', () => {
            localStorage.setItem('senderName', senderNameInput.value);
            // サーバーに更新を送信（接続中の場合）
            if (wsClient.ws && wsClient.ws.readyState === WebSocket.OPEN) {
                wsClient.send({
                    type: 'update-sender-info',
                    streamId: myStreamId,
                    displayName: senderNameInput.value || `送信側-${myStreamId}`
                });
            }
        });

        // 接続状態の表示
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = '✅ サーバーに接続されています';
                statusElement.className = 'connection-status connected';
                // サーバーに送信側として登録
                wsClient.send({
                    type: 'register',
                    role: 'sender',
                    streamId: myStreamId,
                    displayName: senderNameInput.value || `送信側-${myStreamId}`
                });
            } else {
                statusElement.textContent = '❌ サーバーに接続されていません';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // カメラストリームを開始
        async function startCamera() {
            try {
                // HTTPSチェック（iOSでは必須）
                if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    alert('iOSデバイスではHTTPS接続が必要です。\nhttps:// でアクセスしてください。');
                    return;
                }

                // getUserMediaのサポートチェック
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('お使いのブラウザはカメラアクセスに対応していません。\n最新のブラウザをご使用ください。');
                    return;
                }

                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                cameraType.textContent = currentFacingMode === 'user' ? 'インカメラ' : 'アウトカメラ';
                streamState.textContent = '送信中';
                streamState.style.color = '#56ab2f';
                streamStatus.style.display = 'block';

                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                switchCameraBtn.style.display = 'inline-block';

                // サーバーに送信開始を通知（既存の受信側に接続）
                console.log('送信開始を通知');

            } catch (error) {
                console.error('カメラアクセスエラー:', error);
                let errorMessage = 'カメラにアクセスできませんでした。\n\n';
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'カメラの使用が許可されていません。\nブラウザの設定でカメラのアクセスを許可してください。';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'カメラが見つかりません。\nデバイスにカメラが接続されているか確認してください。';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'カメラが他のアプリケーションで使用中の可能性があります。';
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    errorMessage += '指定されたカメラ設定がサポートされていません。';
                } else if (error.name === 'TypeError') {
                    errorMessage += 'HTTPS接続が必要です。\nhttps:// でアクセスしてください。';
                } else {
                    errorMessage += error.message;
                }
                
                alert(errorMessage);
            }
        }

        // カメラストリームを停止
        function stopCamera() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
            }

            // すべてのピア接続を閉じる
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            streamState.textContent = '停止中';
            streamState.style.color = '#999';
            cameraType.textContent = '未選択';

            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            switchCameraBtn.style.display = 'none';
        }

        // カメラを切り替え
        async function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            stopCamera();
            await startCamera();
        }

        // WebRTC接続を開始（受信側ごとに作成）
        async function createPeerConnection(receiverId) {
            try {
                const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                // ローカルストリームを追加
                console.log(`ローカルストリームのトラック数: ${localStream.getTracks().length}`);
                localStream.getTracks().forEach(track => {
                    console.log(`トラックを追加: ${track.kind} (${track.id})`);
                    peerConnection.addTrack(track, localStream);
                });

                // 接続状態の監視
                peerConnection.onconnectionstatechange = () => {
                    console.log(`送信側接続状態 (${receiverId}):`, peerConnection.connectionState);
                };

                // ICE候補を送信
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log(`送信側ICE候補を送信 (${receiverId})`);
                        wsClient.send({
                            type: 'webrtc-ice-candidate',
                            candidate: event.candidate,
                            streamId: myStreamId,
                            receiverId: receiverId
                        });
                    }
                };

                // Offerを作成して送信
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                console.log(`Offerを送信 (${receiverId})`);
                wsClient.send({
                    type: 'webrtc-offer',
                    offer: offer,
                    streamId: myStreamId,
                    receiverId: receiverId
                });

                peerConnections[receiverId] = peerConnection;

            } catch (error) {
                console.error('WebRTC接続エラー:', error);
                alert('WebRTC接続に失敗しました: ' + error.message);
            }
        }

        // WebRTCシグナリング
        wsClient.onMessage(async (data) => {
            try {
                // 新しい受信側が接続した場合
                if (data.type === 'new-receiver' && localStream) {
                    console.log('新しい受信側を検出:', data.receiverId);
                    await createPeerConnection(data.receiverId);
                }
                // Answerを受信
                else if (data.type === 'webrtc-answer') {
                    const receiverId = data.receiverId;
                    const pc = peerConnections[receiverId];
                    if (pc) {
                        console.log(`Answerを受信 (${receiverId})`);
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    }
                }
                // ICE候補を受信
                else if (data.type === 'webrtc-ice-candidate' && data.streamId === myStreamId) {
                    const receiverId = data.receiverId;
                    const pc = peerConnections[receiverId];
                    if (pc) {
                        console.log(`受信側からICE候補を受信 (${receiverId})`);
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                }
                // 受信側が切断した場合
                else if (data.type === 'receiver-disconnected') {
                    const receiverId = data.receiverId;
                    if (peerConnections[receiverId]) {
                        peerConnections[receiverId].close();
                        delete peerConnections[receiverId];
                        console.log(`受信側が切断しました (${receiverId})`);
                    }
                }
            } catch (error) {
                console.error('シグナリング処理エラー:', error);
            }
        });

        // イベントリスナー
        startBtn.addEventListener('click', startCamera);
        stopBtn.addEventListener('click', stopCamera);
        switchCameraBtn.addEventListener('click', switchCamera);
    </script>
</body>

</html>