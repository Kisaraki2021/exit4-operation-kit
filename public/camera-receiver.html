<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡ - 4ç•ªå‡ºå£</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .video-item {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .video-item video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-label {
            background: #667eea;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>ğŸ“º ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡</h1>

            <div class="connection-status" id="connection-status">æ¥ç¶šä¸­...</div>

            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">å—ä¿¡ä¸­ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°:</span>
                    <span class="status-value" id="stream-count">0</span>
                </div>
            </div>

            <div id="video-grid" class="video-grid">
                <!-- å—ä¿¡ã—ãŸãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>

            <div id="no-stream-message" style="text-align: center; color: #999; margin: 40px 0; font-size: 1.2em;">
                å—ä¿¡å¾…æ©Ÿä¸­...
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">ğŸ  ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const videoGrid = document.getElementById('video-grid');
        const streamCount = document.getElementById('stream-count');
        const noStreamMessage = document.getElementById('no-stream-message');

        let peerConnections = [];
        let streamCounter = 0;

        // æ¥ç¶šçŠ¶æ…‹ã®è¡¨ç¤º
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = 'âœ… ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™';
                statusElement.className = 'connection-status connected';
            } else {
                statusElement.textContent = 'âŒ ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤º
        function addRemoteStream(stream) {
            streamCounter++;

            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            videoItem.id = `stream-${streamCounter}`;

            const label = document.createElement('div');
            label.className = 'video-label';
            label.textContent = `ã‚«ãƒ¡ãƒ© ${streamCounter}`;

            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.srcObject = stream;

            videoItem.appendChild(label);
            videoItem.appendChild(video);
            videoGrid.appendChild(videoItem);

            updateStreamCount();
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°ã‚’æ›´æ–°
        function updateStreamCount() {
            const count = videoGrid.children.length;
            streamCount.textContent = count;

            if (count > 0) {
                noStreamMessage.style.display = 'none';
            } else {
                noStreamMessage.style.display = 'block';
            }
        }

        // WebRTCæ¥ç¶šã‚’å‡¦ç†
        wsClient.onMessage(async (data) => {
            if (data.type === 'webrtc-offer') {
                try {
                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });

                    // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å—ä¿¡
                    peerConnection.ontrack = (event) => {
                        addRemoteStream(event.streams[0]);
                    };

                    // ICEå€™è£œã‚’é€ä¿¡
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            wsClient.send({
                                type: 'webrtc-ice-candidate',
                                candidate: event.candidate
                            });
                        }
                    };

                    // æ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–
                    peerConnection.onconnectionstatechange = () => {
                        console.log('æ¥ç¶šçŠ¶æ…‹:', peerConnection.connectionState);
                        if (peerConnection.connectionState === 'disconnected' ||
                            peerConnection.connectionState === 'failed' ||
                            peerConnection.connectionState === 'closed') {
                            // åˆ‡æ–­ã•ã‚ŒãŸå ´åˆã®å‡¦ç†
                            const index = peerConnections.indexOf(peerConnection);
                            if (index > -1) {
                                peerConnections.splice(index, 1);
                            }
                        }
                    };

                    // Offerã‚’è¨­å®šã—ã¦Answerã‚’ä½œæˆ
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    // Answerã‚’é€ä¿¡
                    wsClient.send({
                        type: 'webrtc-answer',
                        answer: answer
                    });

                    peerConnections.push(peerConnection);
                } catch (error) {
                    console.error('WebRTCæ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
                }
            } else if (data.type === 'webrtc-ice-candidate') {
                // ICEå€™è£œã‚’è¿½åŠ 
                for (const pc of peerConnections) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } catch (error) {
                        console.error('ICEå€™è£œè¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            }
        });

        updateStreamCount();
    </script>
</body>

</html>