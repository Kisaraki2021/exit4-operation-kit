<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡ - 4ç•ªå‡ºå£</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .video-item {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .video-item video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-label {
            background: #667eea;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>ğŸ“º ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡</h1>

            <div class="connection-status" id="connection-status">æ¥ç¶šä¸­...</div>

            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">å—ä¿¡ä¸­ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°:</span>
                    <span class="status-value" id="stream-count">0</span>
                </div>
            </div>

            <div id="video-grid" class="video-grid">
                <!-- å—ä¿¡ã—ãŸãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>

            <div id="no-stream-message" style="text-align: center; color: #999; margin: 40px 0; font-size: 1.2em;">
                å—ä¿¡å¾…æ©Ÿä¸­...
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">ğŸ  ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const videoGrid = document.getElementById('video-grid');
        const streamCount = document.getElementById('stream-count');
        const noStreamMessage = document.getElementById('no-stream-message');

        let peerConnections = {}; // streamId -> RTCPeerConnection
        let streamCounter = 0;
        let myReceiverId = Math.random().toString(36).substr(2, 9); // ã“ã®å—ä¿¡å´ã®ID

        // æ¥ç¶šçŠ¶æ…‹ã®è¡¨ç¤º
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = 'âœ… ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™';
                statusElement.className = 'connection-status connected';
                // ã‚µãƒ¼ãƒãƒ¼ã«å—ä¿¡å´ã¨ã—ã¦ç™»éŒ²
                wsClient.send({
                    type: 'register',
                    role: 'receiver',
                    receiverId: myReceiverId
                });
            } else {
                statusElement.textContent = 'âŒ ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤º
        function addRemoteStream(stream, streamId) {
            streamCounter++;

            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            videoItem.id = `stream-${streamId}`;

            const label = document.createElement('div');
            label.className = 'video-label';
            label.textContent = `ã‚«ãƒ¡ãƒ© ${streamCounter} (ID: ${streamId})`;

            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.srcObject = stream;

            videoItem.appendChild(label);
            videoItem.appendChild(video);
            videoGrid.appendChild(videoItem);

            updateStreamCount();
            console.log(`ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ (${streamId})`);
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‰Šé™¤
        function removeStream(streamId) {
            const videoItem = document.getElementById(`stream-${streamId}`);
            if (videoItem) {
                videoItem.remove();
                updateStreamCount();
                console.log(`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã—ãŸ (${streamId})`);
            }
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°ã‚’æ›´æ–°
        function updateStreamCount() {
            const count = videoGrid.children.length;
            streamCount.textContent = count;

            if (count > 0) {
                noStreamMessage.style.display = 'none';
            } else {
                noStreamMessage.style.display = 'block';
            }
        }

        // ç‰¹å®šã®é€ä¿¡å´ã¨ã®æ¥ç¶šã‚’ç¢ºç«‹
        async function connectToSender(streamId) {
            try {
                console.log(`é€ä¿¡å´ã«æ¥ç¶šã‚’è¦æ±‚ (${streamId})`);

                // ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šè¦æ±‚ã‚’é€ä¿¡
                wsClient.send({
                    type: 'request-connection',
                    streamId: streamId,
                    receiverId: myReceiverId
                });
            } catch (error) {
                console.error('æ¥ç¶šè¦æ±‚ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // WebRTCæ¥ç¶šã‚’å‡¦ç†
        wsClient.onMessage(async (data) => {
            try {
                // æ—¢å­˜ã®é€ä¿¡å´ãƒªã‚¹ãƒˆã‚’å—ä¿¡
                if (data.type === 'sender-list') {
                    console.log('é€ä¿¡å´ãƒªã‚¹ãƒˆ:', data.senders);
                    data.senders.forEach(sender => {
                        connectToSender(sender.streamId);
                    });
                }
                // æ–°ã—ã„é€ä¿¡å´ã‚’æ¤œå‡º
                else if (data.type === 'new-sender') {
                    console.log('æ–°ã—ã„é€ä¿¡å´ã‚’æ¤œå‡º:', data.streamId);
                    connectToSender(data.streamId);
                }
                // Offerã‚’å—ä¿¡
                else if (data.type === 'webrtc-offer') {
                    const streamId = data.streamId;
                    console.log(`Offerã‚’å—ä¿¡ (${streamId})`);

                    // æ—¢å­˜ã®æ¥ç¶šãŒã‚ã‚Œã°é–‰ã˜ã‚‹
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                    }

                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å—ä¿¡
                    peerConnection.ontrack = (event) => {
                        console.log(`ãƒˆãƒ©ãƒƒã‚¯ã‚’å—ä¿¡ (${streamId}):`, event.streams[0]);
                        if (event.streams && event.streams[0]) {
                            addRemoteStream(event.streams[0], streamId);
                        }
                    };

                    // ICEå€™è£œã‚’é€ä¿¡
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log(`å—ä¿¡å´ICEå€™è£œã‚’é€ä¿¡ (${streamId})`);
                            wsClient.send({
                                type: 'webrtc-ice-candidate',
                                candidate: event.candidate,
                                streamId: streamId,
                                receiverId: myReceiverId
                            });
                        }
                    };

                    // æ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–
                    peerConnection.onconnectionstatechange = () => {
                        console.log(`å—ä¿¡å´æ¥ç¶šçŠ¶æ…‹ (${streamId}):`, peerConnection.connectionState);
                        if (peerConnection.connectionState === 'disconnected' ||
                            peerConnection.connectionState === 'failed' ||
                            peerConnection.connectionState === 'closed') {
                            console.log(`æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ (${streamId})`);
                            removeStream(streamId);
                            delete peerConnections[streamId];
                        }
                    };

                    // Offerã‚’è¨­å®šã—ã¦Answerã‚’ä½œæˆ
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    console.log(`Answerã‚’é€ä¿¡ (${streamId})`);
                    wsClient.send({
                        type: 'webrtc-answer',
                        answer: answer,
                        streamId: streamId,
                        receiverId: myReceiverId
                    });

                    peerConnections[streamId] = peerConnection;
                }
                // ICEå€™è£œã‚’å—ä¿¡
                else if (data.type === 'webrtc-ice-candidate') {
                    const streamId = data.streamId;
                    const pc = peerConnections[streamId];
                    if (pc) {
                        console.log(`é€ä¿¡å´ã‹ã‚‰ICEå€™è£œã‚’å—ä¿¡ (${streamId})`);
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                }
                // é€ä¿¡å´ãŒåˆ‡æ–­
                else if (data.type === 'sender-disconnected') {
                    const streamId = data.streamId;
                    console.log(`é€ä¿¡å´ãŒåˆ‡æ–­ã—ã¾ã—ãŸ (${streamId})`);
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                        delete peerConnections[streamId];
                    }
                    removeStream(streamId);
                }
            } catch (error) {
            console.error('WebRTCæ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
            console.error('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.stack);
        }
        });

        updateStreamCount();
    </script>
</body>

</html>