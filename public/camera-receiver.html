<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡ - 4ç•ªå‡ºå£</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .video-item {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .video-item video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-label {
            background: #667eea;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>ğŸ“º ã‚«ãƒ¡ãƒ©æ˜ åƒå—ä¿¡</h1>

            <div class="connection-status" id="connection-status">æ¥ç¶šä¸­...</div>

            <!-- é€ä¿¡å´é¸æŠUI -->
            <div class="status-display">
                <h2>é€ä¿¡å´ã‚’é¸æŠ</h2>
                <div class="status-item">
                    <label for="sender-id-input" style="display: block; margin-bottom: 5px; font-weight: bold;">
                        é€ä¿¡å´IDã‚’å…¥åŠ› (ã¾ãŸã¯ä¸‹ã®ãƒªã‚¹ãƒˆã‹ã‚‰é¸æŠ):
                    </label>
                    <input type="text" id="sender-id-input" placeholder="é€ä¿¡å´ã®IDã‚’å…¥åŠ›" 
                           style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #667eea; border-radius: 5px; margin-bottom: 10px;" />
                    <button class="btn btn-success" id="connect-btn">ğŸ“¡ æ¥ç¶š</button>
                </div>
                
                <div id="sender-list-container" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">åˆ©ç”¨å¯èƒ½ãªé€ä¿¡å´:</h3>
                    <div id="sender-list" style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="text-align: center; color: #999; padding: 20px;">
                            é€ä¿¡å´ã‚’æ¤œç´¢ä¸­...
                        </div>
                    </div>
                </div>
            </div>

            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">å—ä¿¡ä¸­ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°:</span>
                    <span class="status-value" id="stream-count">0</span>
                </div>
            </div>

            <div id="video-grid" class="video-grid">
                <!-- å—ä¿¡ã—ãŸãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>

            <div id="no-stream-message" style="text-align: center; color: #999; margin: 40px 0; font-size: 1.2em;">
                å—ä¿¡å¾…æ©Ÿä¸­...
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">ğŸ  ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const videoGrid = document.getElementById('video-grid');
        const streamCount = document.getElementById('stream-count');
        const noStreamMessage = document.getElementById('no-stream-message');
        const senderIdInput = document.getElementById('sender-id-input');
        const connectBtn = document.getElementById('connect-btn');
        const senderListElement = document.getElementById('sender-list');

        let peerConnections = {}; // streamId -> RTCPeerConnection
        let remoteStreams = {}; // streamId -> MediaStream (å—ä¿¡ã—ãŸã‚¹ãƒˆãƒªãƒ¼ãƒ )
        let streamCounter = 0;
        let myReceiverId = null; // ã“ã®å—ä¿¡å´ã®IDï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å–å¾—ï¼‰
        let availableSenders = new Map(); // streamId -> {displayName, clientId}
        let connectedSenders = new Set(); // æ—¢ã«æ¥ç¶šæ¸ˆã¿ã®streamId

        // æ¥ç¶šçŠ¶æ…‹ã®è¡¨ç¤º
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = 'âœ… ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™';
                statusElement.className = 'connection-status connected';
                // ã‚µãƒ¼ãƒãƒ¼ã«å—ä¿¡å´ã¨ã—ã¦ç™»éŒ²
                wsClient.send({
                    type: 'register',
                    role: 'receiver'
                });
            } else {
                statusElement.textContent = 'âŒ ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // é€ä¿¡å´ãƒªã‚¹ãƒˆã‚’æ›´æ–°
        function updateSenderList() {
            if (availableSenders.size === 0) {
                senderListElement.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">åˆ©ç”¨å¯èƒ½ãªé€ä¿¡å´ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            senderListElement.innerHTML = '';
            availableSenders.forEach((info, streamId) => {
                const senderItem = document.createElement('div');
                senderItem.style.cssText = 'border: 2px solid #667eea; border-radius: 8px; padding: 15px; cursor: pointer; transition: background 0.3s;';
                
                const isConnected = connectedSenders.has(streamId);
                if (isConnected) {
                    senderItem.style.background = '#e8f5e9';
                    senderItem.style.borderColor = '#4caf50';
                }

                senderItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 5px;">
                                ${info.displayName}
                            </div>
                            <div style="font-family: monospace; color: #666; font-size: 0.9em;">
                                ID: ${streamId}
                            </div>
                        </div>
                        <div>
                            ${isConnected ? 
                                '<span style="background: #4caf50; color: white; padding: 5px 15px; border-radius: 20px; font-size: 0.9em;">æ¥ç¶šä¸­</span>' : 
                                '<button class="btn btn-success" style="margin: 0;">æ¥ç¶š</button>'}
                        </div>
                    </div>
                `;

                if (!isConnected) {
                    senderItem.addEventListener('click', () => {
                        senderIdInput.value = streamId;
                        connectToSender(streamId);
                    });
                    senderItem.addEventListener('mouseenter', () => {
                        senderItem.style.background = '#f5f5f5';
                    });
                    senderItem.addEventListener('mouseleave', () => {
                        senderItem.style.background = '';
                    });
                }

                senderListElement.appendChild(senderItem);
            });
        }

        // æ¥ç¶šãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        connectBtn.addEventListener('click', () => {
            const streamId = senderIdInput.value.trim();
            if (streamId) {
                connectToSender(streamId);
            } else {
                alert('é€ä¿¡å´ã®IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            }
        });

        // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¡¨ç¤ºãƒ»æ›´æ–°
        function updateRemoteVideo(streamId) {
            const stream = remoteStreams[streamId];
            if (!stream) {
                console.error(`ã‚¹ãƒˆãƒªãƒ¼ãƒ  ${streamId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                return;
            }

            console.log(`ãƒ“ãƒ‡ã‚ªã‚’æ›´æ–°: ${streamId}`);
            console.log(`ãƒˆãƒ©ãƒƒã‚¯æ•°: ${stream.getTracks().length}`);
            stream.getTracks().forEach(track => {
                console.log(`- ${track.kind}: ${track.readyState}, enabled: ${track.enabled}`);
            });

            // æ—¢ã«ãƒ“ãƒ‡ã‚ªè¦ç´ ãŒã‚ã‚‹å ´åˆ
            let videoItem = document.getElementById(`stream-${streamId}`);
            let video;

            if (videoItem) {
                // æ—¢å­˜ã®ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’å–å¾—
                video = videoItem.querySelector('video');
                console.log(`æ—¢å­˜ã®ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’æ›´æ–° (${streamId})`);
            } else {
                // æ–°ã—ããƒ“ãƒ‡ã‚ªè¦ç´ ã‚’ä½œæˆ
                console.log(`æ–°ã—ã„ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’ä½œæˆ (${streamId})`);
                streamCounter++;
                connectedSenders.add(streamId);

                videoItem = document.createElement('div');
                videoItem.className = 'video-item';
                videoItem.id = `stream-${streamId}`;

                const label = document.createElement('div');
                label.className = 'video-label';
                const displayName = availableSenders.get(streamId)?.displayName || `é€ä¿¡å´-${streamId}`;
                label.textContent = `${displayName} (ID: ${streamId})`;

                video = document.createElement('video');
                video.autoplay = true;
                video.playsinline = true;
                video.muted = false;
                video.controls = false;
                video.style.width = '100%';
                video.style.height = 'auto';
                video.style.display = 'block';
                video.style.backgroundColor = '#000';

                videoItem.appendChild(label);
                videoItem.appendChild(video);
                videoGrid.appendChild(videoItem);
            }

            // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ãƒ“ãƒ‡ã‚ªè¦ç´ ã«è¨­å®š
            video.srcObject = stream;
            
            // ç¢ºå®Ÿã«å†ç”Ÿã‚’é–‹å§‹
            video.onloadedmetadata = () => {
                console.log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº† (${streamId}), ãƒ“ãƒ‡ã‚ªã‚µã‚¤ã‚º: ${video.videoWidth}x${video.videoHeight}`);
                video.play()
                    .then(() => console.log(`ãƒ“ãƒ‡ã‚ªå†ç”Ÿé–‹å§‹ (${streamId})`))
                    .catch(e => console.error(`ãƒ“ãƒ‡ã‚ªå†ç”Ÿã‚¨ãƒ©ãƒ¼ (${streamId}):`, e));
            };

            // æ—¢ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯å³åº§ã«å†ç”Ÿ
            if (video.readyState >= 1) {
                console.log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿æ¸ˆã¿ã€å†ç”Ÿã‚’é–‹å§‹ (${streamId})`);
                video.play()
                    .then(() => console.log(`ãƒ“ãƒ‡ã‚ªå†ç”Ÿé–‹å§‹ (${streamId})`))
                    .catch(e => console.error(`ãƒ“ãƒ‡ã‚ªå†ç”Ÿã‚¨ãƒ©ãƒ¼ (${streamId}):`, e));
            }

            updateStreamCount();
            updateSenderList();
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‰Šé™¤
        function removeStream(streamId) {
            const videoItem = document.getElementById(`stream-${streamId}`);
            if (videoItem) {
                // ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’å–å¾—ã—ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
                const video = videoItem.querySelector('video');
                if (video) {
                    video.srcObject = null;
                }
                videoItem.remove();
                connectedSenders.delete(streamId);
                updateStreamCount();
                updateSenderList();
                console.log(`ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã—ãŸ (${streamId})`);
            }
            
            // MediaStreamã‚‚å‰Šé™¤
            if (remoteStreams[streamId]) {
                remoteStreams[streamId].getTracks().forEach(track => track.stop());
                delete remoteStreams[streamId];
            }
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒ æ•°ã‚’æ›´æ–°
        function updateStreamCount() {
            const count = videoGrid.children.length;
            streamCount.textContent = count;

            if (count > 0) {
                noStreamMessage.style.display = 'none';
            } else {
                noStreamMessage.style.display = 'block';
            }
        }

        // ç‰¹å®šã®é€ä¿¡å´ã¨ã®æ¥ç¶šã‚’ç¢ºç«‹
        async function connectToSender(streamId) {
            try {
                console.log(`é€ä¿¡å´ã«æ¥ç¶šã‚’è¦æ±‚ (${streamId})`);

                // ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šè¦æ±‚ã‚’é€ä¿¡
                wsClient.send({
                    type: 'request-connection',
                    streamId: streamId,
                    receiverId: myReceiverId
                });
            } catch (error) {
                console.error('æ¥ç¶šè¦æ±‚ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // WebRTCæ¥ç¶šã‚’å‡¦ç†
        wsClient.onMessage(async (data) => {
            try {
                // ç™»éŒ²å®Œäº†é€šçŸ¥ã‚’å—ä¿¡
                if (data.type === 'registered' && data.role === 'receiver') {
                    myReceiverId = data.clientId;
                    console.log(`å—ä¿¡å´ã¨ã—ã¦ç™»éŒ²ã•ã‚Œã¾ã—ãŸ: ${myReceiverId}`);
                    // é€ä¿¡å´ãƒªã‚¹ãƒˆã‚’è¦æ±‚
                    wsClient.send({
                        type: 'request-sender-list'
                    });
                    return;
                }
                
                // æ—¢å­˜ã®é€ä¿¡å´ãƒªã‚¹ãƒˆã‚’å—ä¿¡
                if (data.type === 'sender-list') {
                    console.log('é€ä¿¡å´ãƒªã‚¹ãƒˆ:', data.senders);
                    availableSenders.clear();
                    data.senders.forEach(sender => {
                        availableSenders.set(sender.streamId, {
                            displayName: sender.displayName || `é€ä¿¡å´-${sender.streamId}`,
                            clientId: sender.clientId
                        });
                    });
                    updateSenderList();
                }
                // æ–°ã—ã„é€ä¿¡å´ã‚’æ¤œå‡º
                else if (data.type === 'new-sender') {
                    console.log('æ–°ã—ã„é€ä¿¡å´ã‚’æ¤œå‡º:', data.streamId, data.displayName);
                    availableSenders.set(data.streamId, {
                        displayName: data.displayName || `é€ä¿¡å´-${data.streamId}`,
                        clientId: data.clientId
                    });
                    updateSenderList();
                }
                // é€ä¿¡å´æƒ…å ±ã®æ›´æ–°
                else if (data.type === 'sender-info-updated') {
                    console.log('é€ä¿¡å´æƒ…å ±æ›´æ–°:', data.streamId, data.displayName);
                    if (availableSenders.has(data.streamId)) {
                        availableSenders.get(data.streamId).displayName = data.displayName;
                        updateSenderList();
                        
                        // æ—¢ã«æ¥ç¶šã—ã¦ã„ã‚‹å ´åˆã¯ãƒ©ãƒ™ãƒ«ã‚‚æ›´æ–°
                        const videoItem = document.getElementById(`stream-${data.streamId}`);
                        if (videoItem) {
                            const label = videoItem.querySelector('.video-label');
                            if (label) {
                                label.textContent = `${data.displayName} (ID: ${data.streamId})`;
                            }
                        }
                    }
                }
                // Offerã‚’å—ä¿¡
                else if (data.type === 'webrtc-offer') {
                    const streamId = data.streamId;
                    console.log(`Offerã‚’å—ä¿¡ (${streamId})`);

                    // æ—¢å­˜ã®æ¥ç¶šãŒã‚ã‚Œã°é–‰ã˜ã‚‹
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                    }

                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å—ä¿¡
                    peerConnection.ontrack = (event) => {
                        console.log(`ğŸ“¥ ãƒˆãƒ©ãƒƒã‚¯ã‚’å—ä¿¡ (${streamId}): ${event.track.kind} (ID: ${event.track.id})`);
                        
                        // MediaStreamã‚’ä½œæˆã¾ãŸã¯å–å¾—
                        if (!remoteStreams[streamId]) {
                            console.log(`ğŸ†• æ–°ã—ã„MediaStreamã‚’ä½œæˆ (${streamId})`);
                            remoteStreams[streamId] = new MediaStream();
                        }
                        
                        // ãƒˆãƒ©ãƒƒã‚¯ã‚’è¿½åŠ 
                        const stream = remoteStreams[streamId];
                        const existingTrack = stream.getTracks().find(t => t.id === event.track.id);
                        if (!existingTrack) {
                            stream.addTrack(event.track);
                            console.log(`âœ… ãƒˆãƒ©ãƒƒã‚¯ã‚’è¿½åŠ : ${event.track.kind}, ç¾åœ¨ã®ãƒˆãƒ©ãƒƒã‚¯æ•°: ${stream.getTracks().length}`);
                        } else {
                            console.log(`âš ï¸ ãƒˆãƒ©ãƒƒã‚¯ ${event.track.id} ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™`);
                        }
                        
                        // ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’æ›´æ–°ï¼ˆãƒˆãƒ©ãƒƒã‚¯ãŒæƒã†ã®ã‚’å¾…ã¤ï¼‰
                        updateRemoteVideo(streamId);
                    };

                    // ICEå€™è£œã‚’é€ä¿¡
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log(`å—ä¿¡å´ICEå€™è£œã‚’é€ä¿¡ (${streamId})`);
                            wsClient.send({
                                type: 'webrtc-ice-candidate',
                                candidate: event.candidate,
                                streamId: streamId,
                                receiverId: myReceiverId
                            });
                        }
                    };

                    // æ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–
                    peerConnection.onconnectionstatechange = () => {
                        console.log(`å—ä¿¡å´æ¥ç¶šçŠ¶æ…‹ (${streamId}):`, peerConnection.connectionState);
                        if (peerConnection.connectionState === 'disconnected' ||
                            peerConnection.connectionState === 'failed' ||
                            peerConnection.connectionState === 'closed') {
                            console.log(`æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ (${streamId})`);
                            removeStream(streamId);
                            delete peerConnections[streamId];
                        }
                    };

                    // Offerã‚’è¨­å®šã—ã¦Answerã‚’ä½œæˆ
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    console.log(`Answerã‚’é€ä¿¡ (${streamId})`);
                    wsClient.send({
                        type: 'webrtc-answer',
                        answer: answer,
                        streamId: streamId,
                        receiverId: myReceiverId
                    });

                    peerConnections[streamId] = peerConnection;
                }
                // ICEå€™è£œã‚’å—ä¿¡
                else if (data.type === 'webrtc-ice-candidate') {
                    const streamId = data.streamId;
                    const pc = peerConnections[streamId];
                    if (pc) {
                        console.log(`é€ä¿¡å´ã‹ã‚‰ICEå€™è£œã‚’å—ä¿¡ (${streamId})`);
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                }
                // é€ä¿¡å´ãŒåˆ‡æ–­
                else if (data.type === 'sender-disconnected') {
                    const streamId = data.streamId;
                    console.log(`é€ä¿¡å´ãŒåˆ‡æ–­ã—ã¾ã—ãŸ (${streamId})`);
                    availableSenders.delete(streamId);
                    updateSenderList();
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                        delete peerConnections[streamId];
                    }
                    removeStream(streamId);
                }
            } catch (error) {
            console.error('WebRTCæ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
            console.error('ã‚¨ãƒ©ãƒ¼è©³ç´°:', error.stack);
        }
        });

        updateStreamCount();
    </script>
</body>

</html>