<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カメラ映像受信 - 4番出口</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .video-item {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .video-item video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-label {
            background: #667eea;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="card">
            <h1>📺 カメラ映像受信</h1>

            <div class="connection-status" id="connection-status">接続中...</div>

            <!-- 送信側選択UI -->
            <div class="status-display">
                <h2>送信側を選択</h2>
                <div class="status-item">
                    <label for="sender-id-input" style="display: block; margin-bottom: 5px; font-weight: bold;">
                        送信側IDを入力 (または下のリストから選択):
                    </label>
                    <input type="text" id="sender-id-input" placeholder="送信側のIDを入力" 
                           style="width: 100%; padding: 10px; font-size: 16px; border: 2px solid #667eea; border-radius: 5px; margin-bottom: 10px;" />
                    <button class="btn btn-success" id="connect-btn">📡 接続</button>
                </div>
                
                <div id="sender-list-container" style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">利用可能な送信側:</h3>
                    <div id="sender-list" style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="text-align: center; color: #999; padding: 20px;">
                            送信側を検索中...
                        </div>
                    </div>
                </div>
            </div>

            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">受信中のストリーム数:</span>
                    <span class="status-value" id="stream-count">0</span>
                </div>
            </div>

            <div id="video-grid" class="video-grid">
                <!-- 受信したビデオストリームがここに追加されます -->
            </div>

            <div id="no-stream-message" style="text-align: center; color: #999; margin: 40px 0; font-size: 1.2em;">
                受信待機中...
            </div>

            <div class="button-group">
                <a href="/" class="nav-link">
                    <button class="btn">🏠 ホームに戻る</button>
                </a>
            </div>
        </div>
    </div>

    <script src="/js/websocket.js"></script>
    <script>
        const statusElement = document.getElementById('connection-status');
        const videoGrid = document.getElementById('video-grid');
        const streamCount = document.getElementById('stream-count');
        const noStreamMessage = document.getElementById('no-stream-message');
        const senderIdInput = document.getElementById('sender-id-input');
        const connectBtn = document.getElementById('connect-btn');
        const senderListElement = document.getElementById('sender-list');

        let peerConnections = {}; // streamId -> RTCPeerConnection
        let remoteStreams = {}; // streamId -> MediaStream (受信したストリーム)
        let streamCounter = 0;
        let myReceiverId = null; // この受信側のID（サーバーから取得）
        let availableSenders = new Map(); // streamId -> {displayName, clientId}
        let connectedSenders = new Set(); // 既に接続済みのstreamId

        // 接続状態の表示
        wsClient.onStatusChange((isConnected) => {
            if (isConnected) {
                statusElement.textContent = '✅ サーバーに接続されています';
                statusElement.className = 'connection-status connected';
                // サーバーに受信側として登録
                wsClient.send({
                    type: 'register',
                    role: 'receiver'
                });
            } else {
                statusElement.textContent = '❌ サーバーに接続されていません';
                statusElement.className = 'connection-status disconnected';
            }
        });

        // 送信側リストを更新
        function updateSenderList() {
            if (availableSenders.size === 0) {
                senderListElement.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">利用可能な送信側がありません</div>';
                return;
            }

            senderListElement.innerHTML = '';
            availableSenders.forEach((info, streamId) => {
                const senderItem = document.createElement('div');
                senderItem.style.cssText = 'border: 2px solid #667eea; border-radius: 8px; padding: 15px; cursor: pointer; transition: background 0.3s;';
                
                const isConnected = connectedSenders.has(streamId);
                if (isConnected) {
                    senderItem.style.background = '#e8f5e9';
                    senderItem.style.borderColor = '#4caf50';
                }

                senderItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 5px;">
                                ${info.displayName}
                            </div>
                            <div style="font-family: monospace; color: #666; font-size: 0.9em;">
                                ID: ${streamId}
                            </div>
                        </div>
                        <div>
                            ${isConnected ? 
                                '<span style="background: #4caf50; color: white; padding: 5px 15px; border-radius: 20px; font-size: 0.9em;">接続中</span>' : 
                                '<button class="btn btn-success" style="margin: 0;">接続</button>'}
                        </div>
                    </div>
                `;

                if (!isConnected) {
                    senderItem.addEventListener('click', () => {
                        senderIdInput.value = streamId;
                        connectToSender(streamId);
                    });
                    senderItem.addEventListener('mouseenter', () => {
                        senderItem.style.background = '#f5f5f5';
                    });
                    senderItem.addEventListener('mouseleave', () => {
                        senderItem.style.background = '';
                    });
                }

                senderListElement.appendChild(senderItem);
            });
        }

        // 接続ボタンのイベント
        connectBtn.addEventListener('click', () => {
            const streamId = senderIdInput.value.trim();
            if (streamId) {
                connectToSender(streamId);
            } else {
                alert('送信側のIDを入力してください');
            }
        });

        // リモートストリームを表示・更新
        function updateRemoteVideo(streamId) {
            const stream = remoteStreams[streamId];
            if (!stream) {
                console.error(`ストリーム ${streamId} が見つかりません`);
                return;
            }

            console.log(`ビデオを更新: ${streamId}`);
            console.log(`トラック数: ${stream.getTracks().length}`);
            stream.getTracks().forEach(track => {
                console.log(`- ${track.kind}: ${track.readyState}, enabled: ${track.enabled}`);
            });

            // 既にビデオ要素がある場合
            let videoItem = document.getElementById(`stream-${streamId}`);
            let video;

            if (videoItem) {
                // 既存のビデオ要素を取得
                video = videoItem.querySelector('video');
                console.log(`既存のビデオ要素を更新 (${streamId})`);
            } else {
                // 新しくビデオ要素を作成
                console.log(`新しいビデオ要素を作成 (${streamId})`);
                streamCounter++;
                connectedSenders.add(streamId);

                videoItem = document.createElement('div');
                videoItem.className = 'video-item';
                videoItem.id = `stream-${streamId}`;

                const label = document.createElement('div');
                label.className = 'video-label';
                const displayName = availableSenders.get(streamId)?.displayName || `送信側-${streamId}`;
                label.textContent = `${displayName} (ID: ${streamId})`;

                video = document.createElement('video');
                video.autoplay = true;
                video.playsinline = true;
                video.muted = false;
                video.controls = false;
                video.style.width = '100%';
                video.style.height = 'auto';
                video.style.display = 'block';
                video.style.backgroundColor = '#000';

                videoItem.appendChild(label);
                videoItem.appendChild(video);
                videoGrid.appendChild(videoItem);
            }

            // ストリームをビデオ要素に設定
            video.srcObject = stream;
            
            // 確実に再生を開始
            video.onloadedmetadata = () => {
                console.log(`メタデータ読み込み完了 (${streamId}), ビデオサイズ: ${video.videoWidth}x${video.videoHeight}`);
                video.play()
                    .then(() => console.log(`ビデオ再生開始 (${streamId})`))
                    .catch(e => console.error(`ビデオ再生エラー (${streamId}):`, e));
            };

            // 既にメタデータが読み込まれている場合は即座に再生
            if (video.readyState >= 1) {
                console.log(`メタデータ読み込み済み、再生を開始 (${streamId})`);
                video.play()
                    .then(() => console.log(`ビデオ再生開始 (${streamId})`))
                    .catch(e => console.error(`ビデオ再生エラー (${streamId}):`, e));
            }

            updateStreamCount();
            updateSenderList();
        }

        // ストリームを削除
        function removeStream(streamId) {
            const videoItem = document.getElementById(`stream-${streamId}`);
            if (videoItem) {
                // ビデオ要素を取得してストリームをクリア
                const video = videoItem.querySelector('video');
                if (video) {
                    video.srcObject = null;
                }
                videoItem.remove();
                connectedSenders.delete(streamId);
                updateStreamCount();
                updateSenderList();
                console.log(`ストリームを削除しました (${streamId})`);
            }
            
            // MediaStreamも削除
            if (remoteStreams[streamId]) {
                remoteStreams[streamId].getTracks().forEach(track => track.stop());
                delete remoteStreams[streamId];
            }
        }

        // ストリーム数を更新
        function updateStreamCount() {
            const count = videoGrid.children.length;
            streamCount.textContent = count;

            if (count > 0) {
                noStreamMessage.style.display = 'none';
            } else {
                noStreamMessage.style.display = 'block';
            }
        }

        // 特定の送信側との接続を確立
        async function connectToSender(streamId) {
            try {
                console.log(`送信側に接続を要求 (${streamId})`);

                // サーバーに接続要求を送信
                wsClient.send({
                    type: 'request-connection',
                    streamId: streamId,
                    receiverId: myReceiverId
                });
            } catch (error) {
                console.error('接続要求エラー:', error);
            }
        }

        // WebRTC接続を処理
        wsClient.onMessage(async (data) => {
            try {
                // 登録完了通知を受信
                if (data.type === 'registered' && data.role === 'receiver') {
                    myReceiverId = data.clientId;
                    console.log(`受信側として登録されました: ${myReceiverId}`);
                    // 送信側リストを要求
                    wsClient.send({
                        type: 'request-sender-list'
                    });
                    return;
                }
                
                // 既存の送信側リストを受信
                if (data.type === 'sender-list') {
                    console.log('送信側リスト:', data.senders);
                    availableSenders.clear();
                    data.senders.forEach(sender => {
                        availableSenders.set(sender.streamId, {
                            displayName: sender.displayName || `送信側-${sender.streamId}`,
                            clientId: sender.clientId
                        });
                    });
                    updateSenderList();
                }
                // 新しい送信側を検出
                else if (data.type === 'new-sender') {
                    console.log('新しい送信側を検出:', data.streamId, data.displayName);
                    availableSenders.set(data.streamId, {
                        displayName: data.displayName || `送信側-${data.streamId}`,
                        clientId: data.clientId
                    });
                    updateSenderList();
                }
                // 送信側情報の更新
                else if (data.type === 'sender-info-updated') {
                    console.log('送信側情報更新:', data.streamId, data.displayName);
                    if (availableSenders.has(data.streamId)) {
                        availableSenders.get(data.streamId).displayName = data.displayName;
                        updateSenderList();
                        
                        // 既に接続している場合はラベルも更新
                        const videoItem = document.getElementById(`stream-${data.streamId}`);
                        if (videoItem) {
                            const label = videoItem.querySelector('.video-label');
                            if (label) {
                                label.textContent = `${data.displayName} (ID: ${data.streamId})`;
                            }
                        }
                    }
                }
                // Offerを受信
                else if (data.type === 'webrtc-offer') {
                    const streamId = data.streamId;
                    console.log(`Offerを受信 (${streamId})`);

                    // 既存の接続があれば閉じる
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                    }

                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // リモートストリームを受信
                    peerConnection.ontrack = (event) => {
                        console.log(`📥 トラックを受信 (${streamId}): ${event.track.kind} (ID: ${event.track.id})`);
                        
                        // MediaStreamを作成または取得
                        if (!remoteStreams[streamId]) {
                            console.log(`🆕 新しいMediaStreamを作成 (${streamId})`);
                            remoteStreams[streamId] = new MediaStream();
                        }
                        
                        // トラックを追加
                        const stream = remoteStreams[streamId];
                        const existingTrack = stream.getTracks().find(t => t.id === event.track.id);
                        if (!existingTrack) {
                            stream.addTrack(event.track);
                            console.log(`✅ トラックを追加: ${event.track.kind}, 現在のトラック数: ${stream.getTracks().length}`);
                        } else {
                            console.log(`⚠️ トラック ${event.track.id} は既に存在します`);
                        }
                        
                        // ビデオ要素を更新（トラックが揃うのを待つ）
                        updateRemoteVideo(streamId);
                    };

                    // ICE候補を送信
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log(`受信側ICE候補を送信 (${streamId})`);
                            wsClient.send({
                                type: 'webrtc-ice-candidate',
                                candidate: event.candidate,
                                streamId: streamId,
                                receiverId: myReceiverId
                            });
                        }
                    };

                    // 接続状態の監視
                    peerConnection.onconnectionstatechange = () => {
                        console.log(`受信側接続状態 (${streamId}):`, peerConnection.connectionState);
                        if (peerConnection.connectionState === 'disconnected' ||
                            peerConnection.connectionState === 'failed' ||
                            peerConnection.connectionState === 'closed') {
                            console.log(`接続が切断されました (${streamId})`);
                            removeStream(streamId);
                            delete peerConnections[streamId];
                        }
                    };

                    // Offerを設定してAnswerを作成
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    console.log(`Answerを送信 (${streamId})`);
                    wsClient.send({
                        type: 'webrtc-answer',
                        answer: answer,
                        streamId: streamId,
                        receiverId: myReceiverId
                    });

                    peerConnections[streamId] = peerConnection;
                }
                // ICE候補を受信
                else if (data.type === 'webrtc-ice-candidate') {
                    const streamId = data.streamId;
                    const pc = peerConnections[streamId];
                    if (pc) {
                        console.log(`送信側からICE候補を受信 (${streamId})`);
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                }
                // 送信側が切断
                else if (data.type === 'sender-disconnected') {
                    const streamId = data.streamId;
                    console.log(`送信側が切断しました (${streamId})`);
                    availableSenders.delete(streamId);
                    updateSenderList();
                    if (peerConnections[streamId]) {
                        peerConnections[streamId].close();
                        delete peerConnections[streamId];
                    }
                    removeStream(streamId);
                }
            } catch (error) {
            console.error('WebRTC接続エラー:', error);
            console.error('エラー詳細:', error.stack);
        }
        });

        updateStreamCount();
    </script>
</body>

</html>